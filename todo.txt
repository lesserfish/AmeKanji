Read Regex from XML file
Read Template from XML file

Create Regex Parser for JMDict.

Create Deck class and give it the attribute to be able to save itself to a file.

Create main loop of AmeKanji
||
||
|_=> With this we should have a working software, and be able to produce decks.

Then, create the AmeWeb library, so that we can download files

Conclude the remaining Dictionary Parsers

Then finish it off by creating assistant functions, so that using the API feels cleaner.

This will end development of AmeKanji

Then you can start with the JS Api.


Template:
<?xml version="1.0" encoding="UTF-8">
<template>
    <field>
        Kanji Writing: @kanji
        Hiragana Writing: @hiragana

        The level difficulty of this card is: @JLPTLVL
    </field>
</template>


class Ame
{

	ame_result loadConfigurationFromFile( ...
	ame_result loadConfigurationFromString( std::vector<string>  <- change this. new overload
	ame_result loadWordlistFromFile(....
	ame_result loadWordlistFromString( std::vector <stringZ
	ame_result loadTemplateFromFile(....
	ame_result loadTemplateFronString( std::vector <string>
	ame_result loadLibrary()
	template<class T....> ame_result loadLibrary()
	ame_result setParser(
	template<class T... > ame_result setParserManually(std::function<ame_result(T.....
	ame_result setWeb(....
	template<class T...> ame_result setWebManually( std::function<ame_result(....
	ame_result setRegex(...
	template<class T...> ame_result setRegexManually( ....
	ame_result createDeck(AnkiDeck &deck, std::vector<std::string>> Args .....
	
	ame_result SetUpCallback(std::function<void(callbackIno)> f)
	std::function<void(callbackInfo> callbackFunction; // Call this function on every step of the main loop.
}

class AnkiDeck
{
	std::string Fields;
	ame_result SaveToFile(...
	ame_result AsString(....

}

class Library
{
	loadConfiguration(....
	SetParserManually(....
	setParserAutomatically(....
	setWebManually(
	setWebAutomatically(....
	setRegexAutomatically
	setRegexManually
	ame_result PopulateCard(T &card, ....
	ame_result downloadMedia(T &card, std::string directory

}


/* Maybe?
    template<class T> AmeLibrary
    {
        public:
            ...
            ...

            // Sets parser manually
            ame_result setParser(std::function<ame_result(......
            {
                invokeParser = _invokeParser;
            }
            // Sets parser automatically
            ame_result setParser()
            {
                ...
                ...
                ...
            }

            // Sets args manually
            ame_result setArgs(std::vector<std::string> args)
            {
                ...
                ...
            }

            // Sets args automatically
            ame_result setArgs()
            {
                ...
                ...
            }

            ame_result populateCard(T &card, std::vector<std::string> input) {
                invokeParser(card, input, Args);
                ...
                ...
            }

        private:
            std::function<ame_result(T&, std::vector<std::string>, std::vector<std::string>) invokeParser;
            std::function<ame_result(T&, std::vector<std::string>, std::vector<std::string>) applyRegex;

            std:.vector<std::string> Args;
    }

/*

How I think this API should be used:

////
////
////

config.Dictionary = "JMDict";
AmeLibrary<Kanji> library(config);


library_result = library.Load();
if(!library_result.OK)
    return;

std::vector<Kanji> cardList;

for(auto& request in Requests)
{
    Kanji k;
    read_results r = library.populateCard(k, request);
    web_results w = library.downloadCardMedia(k, request);

    if(!r.OK || !w.OK)
        return;
    
    cardList.push_back(k);
}


AnkiDeck deck;
for(Kanji& k : cardList)
{
    AnkiCard card;
    for(Field& f : Template)
    {
        std::string field_str = k.RenderTemplate(f);
        Card.push_back(field_str);
    }
    deck.AddCard(card);
}


deck.save("New Anki Deck.txt");

////
////
////



Notice that on the previous thingy, the fact that we were working with objects of the class Kanji was never truly significant. So this leaves a possibility, for us to write:

void Ame::Run()
{
    ...
    ...
    ...
    switch(config.Mode)
    {
        case "Kanji":
            config.Dictionary = "JMdict";
            return Render<Kanji>();
    }
}

Template<Class T>
int Render()
{
    AmeLibrary<T> library(config);

    library_result = library.Load();
    if(!library_result.OK)
        return;

    std::vector<T> cardList;

    for(auto& request : Requests)
    {
        T c;
        // 
        read_results r = library.populateCard(*c, request);
        web_results w = library(*c);

        if(!read_results.OK || !web_results.OK)
            return;
        
        cardList.push_back(c);
    }

    AnkiDeck deck;
    for(T& c : cardList)
    {
        AnkiCard card;
        for(Field& f : Template)
        {
            std::string field_str = c.RenderTemplate(f);
            Card.push_back(field_str);
        }
        deck.AddCard(card);
    }


    deck.save("New Anki Deck.txt");

}
*/